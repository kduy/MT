%*******************************************************************************
%****************************** Second Chapter *********************************
%*******************************************************************************

\chapter{Introduction}

\ifpdf
    \graphicspath{{Chapter1/Figs/Raster/}{Chapter1/Figs/PDF/}{Chapter1/Figs/}}
\else
    \graphicspath{{Chapter1/Figs/Vector/}{Chapter1/Figs/}}
\fi

- BUILDING ALGEBRA SEMANTIC FOR FLINK STREAMING
- IMPLEMENTATION
\section*{Big Data}
\section*{Data Streaming}
\section*{CQL and related work}
\textbf{Features of stream processing languages}(Fundamental of Stream Processing book page 110)


\section*{Flink and FlinkQL}
\section*{Structure}

Challenge: so flexible on execution model : $t_{app}$ $t_{sys}$



[2014] Fundamentals of Stream Processing- Application Design, Systems, and Analytics.pdf \citep{Henrique:2014}



Sliding Window Query Processing over Data Stream 
by
Lukasz Golab




 Processing data streams is a a different paradigm, and moreover, Java is typicaly 50X less compact than say SQL â€“ significantly more code required. Java and Scala require significant garbage collection which is particularly inefficient and troublesome for in-memory processing.
 
 
 
 \href {http://www.sqlstream.com/blog/2015/03/5-reasons-why-spark-streamings-batch-processing-of-data-streams-is-not-stream-processing/}{}


