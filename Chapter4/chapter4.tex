%*******************************************************************************
%****************************** Second Chapter *********************************
%*******************************************************************************

\chapter{FlinkCQL- Queries over Data Stream}

\ifpdf
    \graphicspath{{Chapter4/Figs/Raster/}{Chapter4/Figs/PDF/}{Chapter4/Figs/}}
\else
    \graphicspath{{Chapter4/Figs/Vector/}{Chapter4/Figs/}}
\fi

In the streaming literature, query language model a stream as a representation for an infinite append-only relation. The append-only stream model effects the following limitations\citep{Ghanem:2008}
\begin{itemize}
\item It limits the applicability of the language since the append-only models cannot represent streams from the various domain( e.g., the update streams or streams that represent concatenation of the states of a fixed size relation).
\item The append-only stream model limits the types of queries that the language can express since only non-blocking queries can produce append-only streams as output
\item The semantics of query composition in the append-only stream model is complex and the meaning of the composed queries is difficult to understand.
\end{itemize}

Query \citep{Babcock:2002} 

Query : Smart Votex , page 2

Window Specification over Data Streams.pdf

[Stream] Evaluate CQL

Designing\_Data\_Intensive\_Applications.pdf



\subsection*{Query}

A query is a request telling system \textbf{what} to do in order to retrieve or alter desired information stored or processed by system. For instances, asking ``How many products are sold today? ''. Queries over data stream and in a traditional DBMS have a lot in common; however, due to characteristic of continuousness in data stream, we may classify a query as one-time query or continuous query \citep{Terry:1992} \citep{Babcock:2002}. 
\begin{itemize}
	\item \textbf{One-time queries} are evaluated once over data set at a given time instant, and terminated after returning its result. This is also called \textit{passive query} \citep{SmartVotex:2011} since system require queries and passively waits for users to issue these queries before executing. 
	\item \textbf{Continuous queries}, in contrast, get evaluated continually as new data arrives to the observed stream. System continuously delivery new results  over time according to the snapshot or state of data stream seen so far. Thus the output of queries is not a single result, but rather new streams of results for further operators if desired. Obviously, continuous queries really fit to user's requirements to observed data streams till its end. 
\end{itemize}



\subsection*{Query Language}
Queries are expressed in terms of some query language. Queries provide for users and programmers a very general way to specify data selections, projections, combination, computation and so on over data set/stream. In the meanwhile, users can send the queries using either imperative or declarative language.

\subsubsection*{Imperative vs. Declarative language}
\begin{itemize}
	\item \textbf{Imperative language} requires users to define explicitly step by step \textbf{how} code should be executed to get \textbf{what} they want. They need to break the program into sequences of commands in particular order for the system to perform. Actually, many existing programming languages are imperative supporting \textit{assignemnt}, \textit{for-loop}, \textit{if-else} statements and so on to construct the complete program. For example, assuming that \textit{StockTick} is a  list of stock transactions,  to filter through \textit{StockTick} to get all stock transactions from `NYSE' only: 
\begin{lstlisting}
	function getTransFromNYSE {
		var fromNYSE = []
		for (var i = 0; i < StockTick.length; i++) {
			if (StockTick[i].Exchange == "NYSE")
				fromNYSE.add(StockTick[i])
		}
	}
\end{lstlisting}
	\item \textbf{Declarative language}, like SQL or LINQ, users just specify \textbf{what} they want - which sort of data, which transformation they want it to be afterwards, but \textbf{not how} to achieve the result. The corresponding declarative program for previous examples is written in SQL language as below:
	\begin{verbatim}
		SELECT * from StockTick where Exchange = "NYSE"
	\end{verbatim}
\end{itemize}

There are several advantages of declarative over imperative language \citep{Martin:2014}

\begin{itemize}
	\item Declarative language is typically more concise , more friendly and easier to work with. For instance, comparing 2 previous programs, the former has 7 lines of code while the latter goes with 1 line. According to \citep{Ronnie:2015}, Java program is typically 50 times less compact than SQL query for the same purpose. Generally, that because they have different level of abstraction. Declarative language already hides complicated implementation details. It makes the program much more simpler but possible for system to introduce underneath improvement without any impact on queries.
	\item Declarative languages, for example SQL, HTML,  are usually followed a set of standard syntaxs which make it more limited in functionality, give the system more room for automatic optimization. 
	\item In terms of parallel execution environment, declarative language like SQL has a better chance to be executed faster. Imperative code instructs its sequence of operators to be performed in a certain order so that it is really hard to parallelize programs across distributed system. In the other hand, declarative queries are more atomic to be implemented in parallel if appropriate.
\end{itemize}

\subsubsection*{SQL-like dialect and LINQ}
Several advantages to SQL-based languages \citep{Henrique:2014}
\begin{itemize}

	\item well-established language
	\item data-at-rest to data-in-motion
	\item standard adopted by virtually all relational database systems. As a result, parsers, visualizers and composers for SQL are readily available.
	\item lie at the heart of relational databases. Extending it is a possible incremental approach to quickly build engine

\end{itemize}
	
\subsubsection*{LINQ}
https://www.linqpad.net/WhyLINQBeatsSQL.aspx


Despite its power, LINQ doesn't deprecate SQL. It takes more than 95 percents of the querying brunt, but you still sometimes need SQL for:

Hand-tweaked queries (especially with optimization or locking hints)

Queries that involve selecting into temporary tables, then querying those tables

Predicated updates and bulk inserts

\subsubsection*{Visual languages} \citep{Henrique:2014}

\subsection*{Operators}
Non-blocking operators




\section{Fundamental Features}

\begin{itemize}
\item Stream-oriented Query Languages and Operators
	\begin{itemize}
		\item Language closure
		\item Windowing
		\item Correlation
		\item Pattern Matching
	\end{itemize}
	
\item Fundamental of Stream Processing : page 110
	\begin{itemize}
		\item Compositional elements
		\item Declarative operators
		\item Expression language
		\item Type System
		\item Windowing
		\item Standard operators and adapters
		\item Modularity
		\item Configuration
		\item Extensiblity
	\end{itemize}
\end{itemize}


\section{Continuous Query Language}


\subsection{Data Type}


\begin{table}[h]
\caption{Data Type}
\centering
\label{table:Data Type}
\setlength\extrarowheight{5pt}
\begin{tabular}{||c|l|l||}
\hline
%\rowcolor[HTML]{ECF4FF} 
%{\color[HTML]{ECF4FF} \textbf{Scala Type}} & {\color[HTML]{ECF4FF} \textbf{Flink Type}} & {\color[HTML]{ECF4FF} \textbf{Viewable as}} \\ \hline
\textbf{Scala Type} &  \textbf{Flink Type} & \textbf{Convertable to} \\ \hline\hline
                    String               &           STRING\_TYPE\_INFO                   &  \\ \hline
                    Boolean				&           BOOLEAN\_TYPE\_INFO                  &   \\ \hline
                   Char					&           CHAR\_TYPE\_INFO                       &  Byte, Short, Integer, Long, Double\\ \hline
					Byte		           	&           BYTE\_TYPE\_INFO                     & Short, Integer, Long,Float, Double \\ \hline
					Short				&           SHORT\_TYPE\_INFO                    & Integer, Long, Float, Double\\ \hline								
					Int					&           INT\_TYPE\_INFO                      & Long, Float, Double\\ \hline
					Long			 		&           LONG\_TYPE\_INFO                     & Float, Double \\ \hline								
					Float				&           FLOAT\_TYPE\_INFO                    & Double \\ \hline
					Double				&           DOUBLE\_TYPE\_INFO                   &   \\ \hline							
	Datetime				&           DATE\_TYPE\_INFO                &        	\\ \hline           							           							           							           							           
\end{tabular}
\end{table}



\subsection{Data Definition Language (DDL)}
\subsubsection{Create Schema}

%\setlength{\grammarparsep}{20pt plus 1pt minus 1pt} % increase separation between rules
\setlength{\grammarindent}{12em} % increase separation between LHS/RHS 

\begin{grammar}

<schema statement> ::= CREATE SCHEMA <schema ident> \\
(<named schema ident>|<anonymous schema>) \\
  { }[EXTENDS <parent schema ident>]

<anonymous schema> ::= `(' typedField \{`,' typedField\}`)'

<typedField> ::= <field ident> <data type>

\end{grammar}
	
	




\subsubsection{Create Stream}
	
					
\begin{grammar}
<Stream statement> ::= CREATE STREAM <schema ident> \\		(<named schema ident>|<anonymous schema> ) \\
{ }[<source>]
sub
<source> ::= (AS <derived source>) | ( SOURCE <raw source>)

<derived source> ::=  <stream ident>| <subSelect>

<raw source> ::= 
				HOST `('<host>, <port>`)'
					\alt FILE `('<file path>, <delimiter>`)'
\end{grammar}


\subsection{Data Manipulation Language (DML)}

\subsubsection{Select}
\begin{grammar}
<select statement> ::= SELECT <target entry> \{, <target entry>\}\\
	FROM <stream references> \\
	WHERE <predicate> \\
	GROUP BY <field ident> \{,<field ident>\} \\
	INTO <stream ident>
	
<stream references> ::= <stream refererence> [<join clause>]

<stream reference> ::= (<stream ident>| <subSelect>) [`['Window specification`]']

<join clause> ::= CROSS JOIN <stream reference>
				\alt [INNER] JOIN <stream reference>

<window specification> ::= 
								SIZE <spec> \\
								{ }[EVERY <spec>]\\
								{ }[PARTITIONED BY <field ident> \{,<field ident>\}]

<spec> ::= <int> ON <field ident>
			\alt <int> <time unit>
			\alt <int>
\end{grammar}


\subsubsection{Insert}

\begin{grammar}
<insert statement> ::= INSERT INTO <stream ident> [AS] 
							(<stream ident> | <subSelect>| <merge>)
\end{grammar}


\subsubsection{Merge}
\begin{grammar}
<merge statement> ::= MERGE <stream ident> `,' <stream ident> {,<stream ident>}
\end{grammar}

\subsubsection{Split}
\begin{grammar}
<split statement> ::= ON <stream ident> \\
						<insert clause> \{, <insert clause>\}
						
<insert clause> ::= INSERT INTO <stream ident> \\SELECT <target entry list> WHERE <predicate>
\end{grammar}

\begin{verbatim}
	on OrderEvent
  insert into LargeOrders select orderId, customer where orderQty >= 100
insert into MediumOrders select orderId, customer where orderQty between 20 and 100
  insert into SmallOrders select orderId, customer where orderQty > 0
\end{verbatim}


\subsection{Operators}
\begin{enumerate}

\item Scala-based Operators
	\begin{itemize}
        \item Arithmetic
        \item Logical
        \item Comparison / Relational
        \item Bitwise
	\end{itemize}
	
 \item List and Range Operators
 	\begin{itemize}
        \item In / Not in
        \item Between
        \item Null
 	\end{itemize}
 \item String Operators
 	\begin{itemize}
        \item Like
        \item Regex
 	\end{itemize}
 \item Function 
 	\begin{itemize}
        \item Aggregate Func
        \item Coversion Func
       	\item Data and Time Func
        \item String func
 	\end{itemize}

\end{enumerate}
Semantic and Implementation of Continuous Sliding window queries over data streams

[thesis] CQL over data stream [BNF] alias



\section{Continuous Query Semantics and Operators}
Semantics of Data Streams and Operators

\href{http://en.wikipedia.org/wiki/Relational\_algebra}{http://en.wikipedia.org/wiki/Relational\_algebra}
\subsection*{Denotation Language}
\subsection*{Lamda Calculus}

\subsection{Abstract Syntax}


\subsection{Domain}

\subsection{Denotation Semantics}








\subsection{Standard Operator}
\begin{itemize}
	\item filter $\sigma$
	\item map $\mu$
	\item grouping $\gamma$  
	\item union $\bigcup$
\end{itemize}

\subsection{Window Operators}
\begin{itemize}
\item Time-based Window
\item Count-based Window
\item Partitioned Window
\end{itemize}



